---
title: "Simulating Raman Fiber Amplifiers in Julia: From Theory to High-Performance Code"
author: "Sarthak Dash"
date: "2025-08-09"
categories: [Raman, Julia]
image: "image.jpg"
code-annotations: hover
bibliography: references.bib
highlight-style: monokai
engine: julia
execute: 
  freeze: true
---

## üöÄ What You‚Äôll Learn in This Post

-   A quick primer on **Raman fiber amplifiers** and their role in modern **optical communication systems**.
-   The **physics and equations** behind **Raman gain** and **signal-pump interactions**.
-   How to **simulate Raman amplifiers** using **Julia programming language** for **high-performance computing**.
-   Techniques to **optimize Julia code** using **StaticArrays**, **in-place operations**, and **memory-efficient design**.
-   Visual plot of **power evolution** along the fiber length.
-   Benchmarking results comparing **Julia vs Python** for scientific simulations.
-   Access to **Julia code snippets**, explanations, and performance tips for hands-on learning.

## ü§î What is Raman fiber amplifier, and why simulate it?

A **Raman fiber amplifier (RFA)** uses the Raman scattering effect to amplify optical signals directly within the transmission fiber itself. Unlike traditional fiber amplifiers that require special dopants in optical fiber, Raman scattering can turn any ordinary optical fiber into an amplifier, making RFAs incredibly versatile for telecommunications systems.

Here are some of the points why RFAs are revolutionary:

-   **Wavelength flexibility**: Raman amplification can be done at any wavelength and in any conventional optical fiber.
-   **Broad bandwidth**: Leads to amplification of large range of wavelengths, essential for dense wavelength division multiplexing (WDM) systems
-   **Distributed amplification**: The entire fiber becomes the gain medium, providing amplification along the transmission path

RFAs are now commonly used in long-haul communication systems that are designed to operate over thousands of kilometers. Simulating these RFAs is crucial, as complex nonlinear interactions between pump and signal beams makes analytical solutions impossible for a practical situation. By modeling the coupled ordinary differential equations (ODE) that govern Raman amplification, we can optimize several aspects of the amplifier design such as pump parameters, fiber lengths, and design systems before performing an expensive experimental validation. Also simulation provides us a handy tool to understand the workings of a system by varying only the desired parameter, which is not possible in a practical system. Now let's discuss why Julia programming language is a good choice to do the simulation.

## ü§∑‚Äç‚ôÇÔ∏è Why Julia?

Julia is uniquely positioned for scientific simulations like RFAs. Here are some of the reasons:

-   **Performance**: With Julia, one can achieve C-like speeds while having Python-like readability. For iterative ODE solving required in RFA simulations, this can lead to dramatically faster computation times‚Äîoften 10-100x faster than Python
-   **Simplicity**: The syntax is intuitive for scientists and engineers. For example, one can write `dP‚Çö = gR*P‚Çö*P‚Çõ - Œ±‚Çõ*P‚Çõ` and it looks exactly like the mathematical equation
-   **Rich Ecosystem**: [DifferentialEquations.jl](https://docs.sciml.ai/DiffEqDocs/stable/) is, IMO, the most sophisticated ODE solver suite in any language, with over 200 methods for solving variety of differential equations, with a focus on speed and flexibility
-   **Scientific Focus**: Julia was designed from the ground up for numerical and scientific computing. It handles the "two-language problem" where one develop the prototype in a high-level language (eg: Python, MATLAB) but implement the main computation in a low-level language for performance (C, FORTRAN).

## üìò Basic theory Refresher

Now before we dive deeper into writing the codes, lets discuss the theory a bit.

### Brief overview of Raman amplification

When light interacts with molecular vibrations in glass, there can be transfer of energy between different wavelengths. This is known as **Raman scattering**. Imagine a high energy photon (pump) that collide with vibrating fiber molecules (phonons), giving up some of their energy becoming a lower energy photon (Stokes) at lower frequency or longer wavelength (The pump photons can also receive energy from phonons leading to higher frequency anti-Stokes photons, but this is usually a weak process at room temperatures). If a signal photon is already present at Stokes frequency, it can lead to **stimulated Raman scattering** leading to amplification of the signal wave at Stokes frequency (and thus Raman gain).

### The power-balance equation

The heart of Raman amplifier simulation lies in two coupled ordinary differential equations (ODEs) that describe how pump and signal (Stokes) powers evolve along the fiber [@agrawal2013; @headley2005] $$
\begin{align} \\
&\mathbf{Signal\ equation:}
&\frac{dP_{s}}{dz}&= g_{R}P_{p}P_{s} - \alpha_{s}P_{s} \\
&\mathbf{Pump\ equation:}
&\frac{dP_{p}}{dz}&= -\frac{\nu_{p}}{\nu_{s} }g_{R}P_{p}P_{s} - \alpha_{p}P_{p}
\end{align}
$$ {#eq-power-balance1} where:

-   $P_{s}$ and $P_{p}$ are signal and pump powers that are a function of position $z$
-   $g_{R}$ is the Raman gain efficiency
-   $\alpha_{s}$ and $\alpha_{p}$ are signal and pump attenuation coefficients
-   $\nu_{s}$ and $\nu_{p}$ are signal and pump frequencies

![Diagram illustrating the power-balance equation](power%20balance.png){#fig-power-balance .lightbox fig-align="center" width="80%"}

The $g_{R}P_{p}P_{s}$ term is the power transfer from pump to signal due to stimulated Raman scattering and the term $-\frac{\nu_{p}}{\nu_{s} }g_{R}P_{p}P_{s}$ represents the power loss in the pump as it is transferred to signal. The reason of the $\nu_{p}/\nu_{s}$ term is due to photon number conservation (in absence of loss) [@agrawal2013].

The power-balance equations describes the initial pump and signal power $P_{p}(0)$ and $P_{s}(0)$ evolves along the fiber length $L$.

#### Key assumptions

The above equations are derived with these assumptions

-   **CW or quasi-CW regime**: both pump and signal assumed to be close to continuous-wave(CW) and so no time dependence is considered, valid assumption in most telecommunications applications.
-   **Single-mode fiber**: both pump and signal waves are in the fundamental mode of fiber, appropriate for standard telecom fibers
-   **Co-propagating**: both pump and signal waves travel in the same direction, valid in most cases and simple to begin with simulation compared to the counter-propagating case.
-   **No dispersion**: the fiber has same mode solutions at both pump and signal waves, an assumption we can easily relax, considered initially only to simplify the simulation.

The beauty of these equations, under the given assumptions, lies in their simplicity ‚Äî yet they capture the essential physics of energy transfer, amplification, and loss in fiber Raman amplifiers.

## üß™ Performing the Simulation in Julia

### Setting up

First, if you don‚Äôt have Julia installed, then download and install [Julia programming language](https://julialang.org/). Follow the [installing Julia](https://julialang.org/install/) instructions. You can also check the [documentation](https://docs.julialang.org/en/v1/) to learn more about Julia. We need several key packages

``` julia
using Pkg
Pkg.add(["DifferentialEquations", 
      "Plots", 
      "BenchmarkTools", 
      "LaTeXStrings", 
      "StaticArrays"])
```

-   We already know about [DifferentialEquations.jl](https://docs.sciml.ai/DiffEqDocs/stable/), the powerhouse ODE solver suite with over 200 methods. This gives us access to robust, high-performance solvers specifically designed for stiff systems common in nonlinear optics.
-   [Plots.jl](https://docs.juliaplots.org/latest/) is Julia's most popular plotting package. Its recipe system leads to `plot(sol)` automatically knowing how to visualize ODE solutions‚Äîperfect for our simulations.
-   [BenchmarkTools.jl](https://juliaci.github.io/BenchmarkTools.jl/stable/) provide professional-grade benchmarking tools in Julia. Essential for optimizing our simulation performance and understanding computational bottlenecks.
-   [LaTeXStrings.jl](https://github.com/JuliaStrings/LaTeXStrings.jl) makes it easy to type LaTeX strings in Julia.
-   [StaticArrays.jl](https://juliaarrays.github.io/StaticArrays.jl/stable/) helps in implementing statically sized arrays in Julia which can lead to performance advantages. More on this will be discussed later.

Now let's import the necessary packages

```{julia}
#| output: false
using DifferentialEquations, Plots, LaTeXStrings, BenchmarkTools
```

### Coding the Physics

Let's implement our Raman amplifier simulation step by step:

#### Step 1: Define the simulation parameters

```{julia}
#| output: false
# ------- Signal parameters -------
Œªs = 1550.0   # Signal wavelength (nm)  
Ps_0 = 1e-3   # Input signal power (W)       

# ------- Pump parameters -------
Œªp = 1450.0   # Pump wavelength (nm)
Pp_0 = 2.0      # Input pump power (W)         

# ------- Fiber parameters -------
Œ±_p = 0.23     # Pump attenuation (dB/km)       
Œ±_s = 0.19     # Signal attenuation (dB/km)     
gR = 0.4       # Raman gain efficiency (1/W/km)
L = 50         # Length of fiber (km)
```

These parameters represent a typical telecommunications fiber Raman amplifier. The fiber parameters taken are for a standard single-mode fiber (SMF).

#### Step 2: Set up the ODE system

```{julia}
#| output: false
function Raman1!(dP, P, a, z)
    Pp, Ps = P
    r, Œ±_p, Œ±_s, gR = a

    dP[1] = -Œ±_p * Pp - r * gR * Pp * Ps # dPp/dz
    dP[2] = -Œ±_s * Ps + gR * Pp * Ps   # dPs/dz
end
```

This function defines our ODE system in the form required by `DifferentialEquations.jl`. The `!` indicates an in-place function that modifies dP directly ‚Äî more efficient for large systems. Here $r$ denotes the ratio of pump to signal frequency $r=\nu_{p}/\nu_{s}$

#### Step 3: Configure and solve the ODE system

First let's define some convenience functions to convert loss from dB/km to 1/km unit and calculate frequency in THz when wavelength is given in nm.

```{julia}
#| output: false
# ------- Convenience functions -------
const c = 299792.458;  # speed of light in nm THz
Œ±_lin(dB::Real) = dB / (10 * log10(exp(1))) # convert loss from dB to linear # <1>
get_ŒΩ(Œª::Real) = c / Œª # get frequency (THz) from wavelength (nm)                      # <1>
to_dBm(P::Real) = 10 * log10(P * 1e3) # convert power from Watt to dBm # <1>
```

1.  By appending `::Real` we are saying the function can take only real numbers like integers, floats, fractions ...

Now we configure the system and solve the ODE.

```{julia}
#| output: false
# Initial conditions and span
P0 = [Pp_0, Ps_0]
zspan = (0.0, L)

# parameters
a = (get_ŒΩ(Œªp)/get_ŒΩ(Œªs), Œ±_lin(Œ±_p), Œ±_lin(Œ±_s), gR) 

# create and solve ode problem
prob = ODEProblem(Raman1!, P0, zspan, a) # creating the ODE problem
sol = solve(prob,Tsit5(), saveat=L/1000) # solving the ODE problem
```

We use `Tsit5()`, a high-quality Runge-Kutta method that's excellent for non-stiff problems. The `saveat` option ensures we get solutions at regular intervals for smooth plotting.

#### Step 4: Visualize the results

```{julia}
#| label: fig-Raman1
#| fig-cap: Power evolution of pump and signal along the fiber length.
plot(sol.t, [to_dBm.(sol[1,:]), to_dBm.(sol[2,:])],
    linewidth = 2,
    xaxis="Length (km)",
    yaxis="Power (dBm)",
    label =[L"P_p" L"P_s"],
    legendfontsize=14,
    legend=:right,
    margin=10Plots.mm)
```

With this, we‚Äôve successfully simulated a Raman fiber amplifier using Julia. A signal at 1550 nm traveling in a standard SMF gets amplified over the length of the fiber due to Raman scattering. We just had to input 2 W of pump power at 1450 nm alongside the signal to achieve this effect.

## üìä Benchmarking

Now that we‚Äôve built a working simulation of a Raman fiber amplifier, it‚Äôs time to evaluate how efficiently it runs. After all, one of the key reasons for choosing Julia is its reputation for high-performance scientific computing.

Julia provides a simple macro, `@time`, which gives a quick estimate of execution time. However, for more rigorous benchmarking, especially when comparing performance across implementations, we turn to the `BenchmarkTools.jl` package. It offers the `@btime` macro, which runs the code multiple times and reports the minimum execution time along with memory allocations.

Let‚Äôs benchmark our solver:

```{julia}
@btime solve(prob,Tsit5(), save_everystep = false); #<1>
```

1.  We just want memory allocations done for solving the ODE and not for saving the values, hence `save_everystep = false`

This result tells us that in executing the code in executing the code `solve(prob,Tsit5(), save_everystep = false)`: - It took about 16 Œºs - It performs 85 heap allocations, consuming about 4.59 KiB of memory.

Heap allocations refer to memory dynamically allocated during runtime. While necessary, excessive allocations can slow down performance. More on heap allocations can be found [here](https://docs.julialang.org/en/v1/manual/performance-tips/) and [here](https://book.sciml.ai/notes/02-Optimizing_Serial_Code/). Fortunately, our current implementation is already quite efficient.

### Why this code runs fast?

Achieving this level of performance isn‚Äôt just about using Julia‚Äîit‚Äôs also about writing optimized code. In writing the code here, I have followed the guidelines of [Code Optimization for Differential Equations](https://docs.sciml.ai/DiffEqDocs/stable/tutorials/faster_ode_example/). For an ODE solver, most of the time will be spent inside the function we are trying to solve. Here‚Äôs what I did to ensure our solver spends minimal time inside the ODE function.:

-   The core function `Raman1!` is written as an in-place function, which avoids unnecessary memory allocations.
-   Pre-computed values like the frequency ratio $\nu_{p}/\nu_{s}$ and unit conversion of parameters outside the ODE function to reduce overhead.
-   Additionally, type stability is ensured (Can be checked using `@code_typed Raman1!(similar(P0), P0, zspan, a)`)

## üöÄ Making the code run even faster

### Boosting Performance with StaticArrays

While our initial simulation is already efficient, we can push performance even further using `StaticArrays.jl` ‚Äî a Julia package designed for small, fixed-size arrays that are allocated on the stack rather than the heap. In Julia, regular arrays are heap-allocated, which means they involve dynamic memory management. For small arrays (like our 2-element power vector), this can be inefficient. Stack-allocated and immutable **StaticArrays** reduces heap allocations and speeds up computation.

To use StaticArrays, we need to make a few changes:

1.  Use `SA[]` instead of regular array constructors
    -   `SA[]` creates a `SVector`, a statically sized vector.
    -   Example: `SA[dPp, dPs]` returns a 2-element static vector.
2.  Switch to an out-of-place function.
    -   Our original function `Raman1!` was in-place, meaning it modified an existing array.
    -   StaticArrays are immutable, so we return a new array instead‚Äîthis is called an out-of-place function.

Here's the updated code:

```{julia}
using StaticArrays 
function Raman1_Static(P, a, z)
    r, Œ±_p, Œ±_s, gR = a
    Pp, Ps = P

    dPp = -Œ±_p * Pp - r * gR * Pp * Ps # dPp/dz
    dPs = -Œ±_s * Ps + gR * Pp * Ps   # dPs/dz
    return SA[dPp, dPs]
end

P0 = SA[Pp_0, Ps_0];  # (pump , signal)power 
a = SA[get_ŒΩ(Œªp)/get_ŒΩ(Œªs), Œ±_lin(Œ±_p), Œ±_lin(Œ±_s), gR];

prob = ODEProblem(Raman1_Static, P0, zspan, a);
@btime solve(prob, Tsit5(), save_everystep=false);
```

That‚Äôs a 3x speedup with significantly fewer allocations ‚Äî an impressive gain for such a small change. This is especially valuable when scaling up simulations or running them repeatedly.

## ‚ú® Bonus: Benchmarking with Python

Lets see how does out Julia code stack up against Python ‚Äî the scientist‚Äôs standby ‚Äî for a task like a Raman fiber amplifier simulation using standard ODE solvers? Below is a self-contained Python version (using NumPy and SciPy) ‚Äî the same ODE and parameters.

:::: {.callout-note icon="false" collapse="true" title="Python code"}
::: {#lst-pythoncode lst-cap=""}
``` python
import numpy as np
from scipy.integrate import solve_ivp

# System ODE
def Raman1(z, P, freq_ratio, alpha_p, alpha_s, gR):
  Pp, Ps = P
  dPp_dz = -gR * Pp * Ps - alpha_p * Pp
  dPs_dz = gR * freq_ratio * Pp * Ps - alpha_s * Ps
  return [dPp_dz, dPs_dz]

# Solve ODE
sol = solve_ivp(Raman1, (0,50.0) , [2.0, 1e-3],
              args=(1550.0/1450.0, 0.23/4.343, 0.19/4.343, 0.4))
```
:::
::::

We use the [PythonCall.jl](https://juliapy.github.io/PythonCall.jl/stable/) package to run native Python code from Julia. Here, we define our Python code as a string in Julia using the syntax `py"""<python code here>"""`. We wrap the above Python [code @lst-pythoncode] within a python function returning the result of `sol` (ODE solved in python) as a dictionary that can be passed to Julia.

```{julia}
#| code-fold: true
using PyCall
# python code as a string
py"""
import numpy as np
from scipy.integrate import solve_ivp

def raman_amp_python():
  # System ODE
  def Raman1(z, P, freq_ratio, alpha_p, alpha_s, gR):
      Pp, Ps = P
      dPp_dz = -gR * Pp * Ps - alpha_p * Pp
      dPs_dz = gR * freq_ratio * Pp * Ps - alpha_s * Ps
      return [dPp_dz, dPs_dz]

  # Solve ODE
  sol = solve_ivp(Raman1, (0,50.0) , [2.0, 1e-3],
                  args=(1550.0/1450.0, 0.23/4.343, 0.19/4.343, 0.4))
  return {
        "z": sol.t,
        "Ps": sol.y[0],
        "Pp": sol.y[1]
    }
"""
# Calling the Python code from Julia
py_raman_amp = py"raman_amp_python"
result = py_raman_amp();
```

Once we have successfully solved the ODE in python by calling it from Julia, now let's benchmark it.

```{julia}
@btime py_raman_amp();
```

The python implementation of the same code is 120x slower than our first Julia implementation and more than 350x slower than out StaticArray based Julia code.

|         Code         | Time taken | Allocations | Memory used |
|:--------------------:|:----------:|:-----------:|:-----------:|
|    Julia (Basic)     |  \~16 Œºs   |     85      |  4.59 KiB   |
| Julia (StaticArrays) |  \~5.5 Œºs  |     25      |  1.92 KiB   |
|        Python        |  \~2.2 ms  |     126     |  5.37 KiB   |

: Comparision of benchmark results

## Conclusion

In this post, we looked at how to simulate Raman amplifiers using Julia. We then tried to optimize the code for performance and finally compared our Julia code with the Python implementation.

Here, I have simulated the co-pumped and single Raman shift based amplifier. In subsequent posts, I‚Äôll explore multiple Raman shifts and also counter-pumped case.